Type Script:
        it is a superset of the javascript which add the static typing

javascript is a loosely typed language 
It can be difficult to understand what types of data are being passed around in JavaScript.

In JavaScript, function parameters and variables don't have any information

So developers need to look at documentation, or guess based on the implementation.

TypeScript allows specifying the types of data being passed around within the code, and has the ability to report errors when the types don't match.


// *******************************************************


data Types:

1.boolean:

    let isactive:boolean =true // the typescript formate
    let haspermission =false // javascript formate

2.number:

    let decimal:number=6;
    let float:number=5.5;
    let hex: number = 0xf00d;  

3.string:

    let color:string="blue";
    let fullname=:string="john doe";

4. symbol:

    const uniqueKey:symbol=Symbol('description');
    const obj={
        [uniqueKey]:"this is the qunique property"
    };
    console.log(obj[uniqueKey])



//  ********************************************************************************************************
Type Annotations and Inference

1.explicity typing: you  explicity declare the  type of the variable
2.type Inference: it automatcially deteermines   the type based on the assign value

When to Use Each Approach
Use explicit types for:
Function parameters and return types
Object literals
When the initial value might not be the final type
Use type inference for:
Simple variable declarations with immediate assignment
When the type is obvious from the context


Inferred:
const user = {
  name: "Alice",
  age: 25
};


Explicit:
type User = {
  name: string;
  age: number;
};

const user: User = {
  name: "Alice",
  age: 25
};


//******************************************************************************

TypeScript Special Types
    1.any: When migrating JavaScript code to TypeScript
When working with dynamic content where the type is unknown
When you need to opt out of type checking for a specific case


        eg:
        let v: any = true;
        v = "string"; 
        Math.round(v);

2.Type: unknown



3.Type: never:
Can be anything, but must be checked first
The never type represents the type of values that never occur.



//  ***********************************************************************

ARRAY:
    const arr:string[] / number[]/datatype[]=[];
    eg: const names:string[]=[];
    names.push("hello");

Readonly : it prevent the array from the changes:
const arr:readonly string[]=[];

type inference array:
    const arr=[1,2,3];
    number.push(4);

//  ********************************************************************************************

tuple:  it is a typed array with the pre defined length and types of the each index
    Tuples are great because they allow each element in the array to be a known type of value.

    defining the tuple:
    eg :let outtuple:[number,string,boolean];

    outtuple=[5,"hello",true];

    and we can not add the values in the wrong order;

    2.readonly tuple:
        let outtuple:readonly[number,boolean,string];
        in this we cannot change the things

// *****************************************************************************************

object types:
    TypeScript has a specific syntax for typing objects.

    eg
    const car :{type:string,model:string,year:number}={
        type:"suv",
        model:"fortuner",
        year:2012
    }
   
   1. Index signatures can be used for objects without a defined list of properties.

// Example
const nameAgeMap: { [index: string]: number } = {};
nameAgeMap.Jack = 25; // no error
nameAgeMap.Mark = "Fifty"; // Error: Type 'string' is not assignable to type 'number'.


// ***********************************************************************
TypeScript Type Aliases and Interfaces


type Aliases:
Type Aliases allow defining types with a custom name (an Alias).

eg:
type CarYear = number //type Aliases
type CarType = string //type Aliases
type CarModel = string //type Aliases
type Car = {
  year: CarYear,
  type: CarType,
  model: CarModel
}

const carYear: CarYear = 2001
const carType: CarType = "Toyota"
const carModel: CarModel = "Corolla"
const car: Car = {
  year: carYear,
  type: carType,
  model: carModel
};



type Interfaces:
Interfaces are similar to type aliases, except they only apply to object types.


eg:
    interface Rectangle {
  height: number,
  width: number
}

const rectangle: Rectangle = {
  height: 20,
  width: 10
};


//  ************************************************************

functions :
TypeScript has a specific syntax for typing function parameters and return values.

1.return value
    function gettime() :number //this is the return type value
    {
        return new Date.getTime();
    }


    2.The type void can be used to indicate a function doesn't return any value.
    function printHello(): void {
  console.log('Hello!');
}

parameters :
function multiply(a:number,b:number) :number{
    return a*b;
}


optional parameter:
function add(a:number,b:number,c?.number):number{
    return a+b+(c||0);
}

default parameter :
function multiply(a:number,b:number=10):number{
    return a*b;
    }


rest parameter:

function add(a:number,b:number,...rest:number[]){
    return a+b+rest.reduce((p,c)=>p+c,0);
}

//  **********************************************************************************

TypeScript Casting:



//  ********************************************************************************

TypeScript Classes:
    
    eg: class Person{
        private name:string;

    public constructor(name:string){
this.name=name;
    }
    public getname():string{
return this.name;
    }

    }
const person=new Person("jayesh");
    console.log(person.name)